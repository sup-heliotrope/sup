#!/usr/bin/env ruby

require 'uri'
require 'rubygems'
require 'trollop'
require "sup"; Redwood::check_library_version_against "git"

PROGRESS_UPDATE_INTERVAL = 15 # seconds

class AbortExecution < SystemExit
end

opts = Trollop::options do
  version "sup-migrate-index (sup #{Redwood::VERSION})"
  banner <<EOS
Updates the index from version 4 to 5 by changing ids and references to safe
ids.

Usage:
  sup-migrate-index [options]

Options:
EOS
  opt :verbose, "Print message ids as they're processed."
  opt :ignore_missing, "Silently skip over messages that are not in the index."
  opt :warn_missing, "Warn about messages that are not in the index, but continue."
  opt :abort_missing, "Abort on encountering messages that are not in the index. (default)"
  opt :atomic, "Use transaction to apply all changes atomically."
  opt :dry_run, "Don't actually modify the index. Probably only useful with --verbose.", :short => "-n"
  opt :version, "Show version information", :short => :none

  conflicts :ignore_missing, :warn_missing, :abort_missing
end
Trollop::die "Extra arguments given" if ARGV.length > 1
missing_action = [:ignore_missing, :warn_missing, :abort_missing].find { |x| opts[x] } || :abort_missing

BASE_DIR = ENV["SUP_BASE"] || File.join(ENV["HOME"], ".sup")


Redwood::start
index = Redwood::Index.init

#index.lock_interactively or exit


info "Starting migration to version 5.."

index.load true

xapian = index.get_xapian
db_version = xapian.get_metadata 'version'
db_version = '0' if db_version.empty?

fail "It only makes sense to migrate from version 4 to 5, you have an index version #{db_version}" unless db_version == '4'

num_docs = 0
xapian.postlist('Kmail').each do |x|
  info "Updating document: #{x.inspect}"
  num_docs += 1

  doc = xapian.document(x.docid)
  entry = doc.entry

  debug "Working on entry: #{entry[:message_id]}."

  debug "Adding missing fields.."
  entry[:safe_id] = Redwood::Message.munge_msgid(entry[:message_id])
  entry[:safe_refs] += entry[:refs].nil? ? [] : entry[:refs].compact.map { |r| rr = Redwood::Message.munge_msgid(r); debug "addin ref #{r} -> #{rr}.."; rr }
  entry[:safe_refs] = entry[:safe_refs].uniq


  entry[:safe_replytos] = entry[:replytos].nil? ? [] : entry[:replytos].compact.map { |r| rr = Redwood::Message.munge_msgid(r); debug "addin replyto #{r} -> #{rr}.."; rr }

  next if opts[:dry_run]
  doc.entry = entry

  info "Storing message.."
  xapian.replace_document x.docid, doc
  k = xapian.document x.docid
  info "stored safe_id: " + k.value(0)

  debug "Loading message.."
  #locations = entry[:locations].map do |source_id,source_info|
    #source = Redwood::SourceManager[source_id]
    #raise "invalid source #{source_id}" unless source
    #Redwood::Location.new source, source_info
  #end

  #m = Redwood::Message.new :locations => locations,
                  #:labels => entry[:labels],
                  #:snippet => entry[:snippet]

  ## Try to find person from contacts before falling back to
  ## generating it from the address.
  #mk_person = lambda { |x| Redwood::Person.from_name_and_email(*x.reverse!) }
  #entry[:from] = mk_person[entry[:from]]
  #entry[:to].map!(&mk_person)
  #entry[:cc].map!(&mk_person)
  #entry[:bcc].map!(&mk_person)

  #m.load_from_index! entry
  #m.load_from_source!

  break


end

info "done, updated: #{num_docs} documents."

